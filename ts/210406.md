# 进击的 TypeScript（4）- 泛型

[toc]

## 1. 泛型的重要性

“泛型是 TypeScript 中非常重要的一个概念，因为在之后实际开发中任何时候都离不开泛型的帮助，原因就在于泛型给予开发者创造灵活、可重用代码的能力。”[^1]

“泛型是 TypeScript（以下简称 TS） 比较高级的功能之一，理解起来也比较困难。泛型应用场景非常广泛，很多地方都能看到它的影子。平时我们阅读开源 TS 项目源码，或者在自己的 TS 项目中使用一些第三方库（比如 React）的时候，经常会看到各种泛型定义。**如果你不是特别了解泛型，那么你很可能不仅不会用，不会实现，甚至看不懂这是在干什么。**”[^2]

## 2. 泛型是什么

“软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。**设计泛型的关键目的是在成员之间提供有意义的约束**，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。”[^3]

### 适用场景

两个参考标准

1. 当你的函数、接口或类将处理多种数据类型时
2. 当函数、接口或类在多个地方使用该数据类型时

### 示例 1

首先我们来定义一个 **通用** 的 `identity` 函数，接收一个参数并直接返回它：

```ts
function identity(value) {
    return value;
}
```

假如设定参数 `value` 为 `number` 类型，那么当传 `string` 就没用了。那很简单，改为 `any` 类型不就行了？这样当然也不行：

1. 失去了定义应该返回哪种类型的能力
2. 编译器失去了类型保护的作用

解决方法就是使用 **泛型**，写法如下：

```ts
function identity <T>(value: T): T {
    return value;
}
console.log(identity(123)); // OK
console.log(identity('abc'));   // OK
```

VSC 光标悬停调用函数名称，效果如下：

> 当我们调用 `identity<number>(123)` 时，`number` 类型就会像参数一样，在出现 `T` 的任何位置填充该类型。

![identity-num](https://tva1.sinaimg.cn/large/008i3skNgy1gpzibzvpi5j30mk09874j.jpg)

![identity-str](https://tva1.sinaimg.cn/large/008i3skNgy1gpzice9kkfj30pq0ba0t1.jpg)

说明

* `<T>` 中的 `T` 被称为类型变量，是我们希望传递给函数的类型占位符
* `T` 代表 **Type**，在定义泛型时通常用作第一个类型变量名称
* `T` 可以用任何有效名称代替，常见泛型变量代表还有：
  * `K`（Key）：表示对象中的键类型
  * `V`（Value）：表示对象中的值类型
  * `E`（Element）：表示元素类型

### 示例 2

如何引入希望定义的任何数量的类型变量？

例如引入一个新的类型变量 `U`，用于扩展我们定义的 `identity` 函数：

```ts
function identity<T, U>(value: T, message: U): T {
    console.log(message);
    return value;
}

console.log(identity<number, string>(68, "Tony"));  // OK
```

注意到上面返回类型只有 `T`，那么如果要返回两种类型呢？——使用 **元组**。

```ts
function identity<T, U>(value: T, message: U): [T, U] {
    console.log(message);
    return [value, message];
}

console.log(identity<number, string>(68, "Tony"));  // OK
```

除了元组还有其他更好的方案？——使用 **泛型接口**。

## 3. 泛型接口

示例

```ts
// 定义一个用于 `identity` 函数的通用接口 `Identities`
interface Identities<V, M> {
    value: V,
    message: M
}

function identity<T, U> (value: T, message: U): Identities<T, U> {
    console.log(value + ': ' + typeof(value));
    console.log(message + ': ' + typeof(message));
    let identities: Identities<T, U> = {
        value,
        message
    }
    return identities;
}

console.log(identity(68, 'Tony'));  // OK
```

## 4. 泛型类

泛型除了可以应用在函数和接口外，也可以应用在类中。

在类中使用泛型，只需在类名后面，使用 `<T, ...>` 的语法定义任意多个类型变量：

```ts
interface GenericInterface<U> {
    value: U,
    getIdentity: () => U
}

// `IdentityClass` 实现 `GenericInterface<T>`，
// 当 `T` 表示 `number` 类型时，等于 `IdentityClass` 实现了 `GenericInterface<number>`
class IdentityClass<T> implements GenericInterface<T> {
    value: T;

    constructor(value: T) {
        this.value = value;
    }

    getIdentity(): T {
        return this.value;
    }
}

const myNumberClass = new IdentityClass<number>(68);
console.log(myNumberClass.getIdentity());   // => 68

const myStringClass = new IdentityClass<string>('Tony');
console.log(myStringClass.getIdentity());   // => Tony
```

## 5. 泛型约束

泛型约束作用：限制每个类型变量接受的类型数量。

两种常见场景

1. 确保属性存在
2. 检查对象上的键是否存在

### 确保属性存在

例如，当我们处理字符串或数组时，假设 `length` 属性可用：

```ts
function identity<T>(arg: T): T {
    console.log(arg.length); // Error, 类型“T”上不存在属性“length”
    return arg;
}
```

这种情况下，编译器不知道 `T` 是否包含 `length` 属性，因为我们可以把任何类型赋值给类型变量 `T`。那么该如何做才能让 TS 编译器相信 `T` 有 `length` 属性呢？有以下两种处理方式：

方式 1 - 继承属性接口类型

```ts
interface Length {
    length: number;
}

// 让 `T` 实现继承接口类型 `Length`
function identity<T extends Length>(arg: T): T {
    console.log(arg.length);
    return arg;
}

// identity(68);   // Error, 类型“number”的参数不能赋给类型“Length”的参数。
identity('string'); // OK
identity([1, 2, 3]);    // OK
```

> 我们还可以用 `,` 号来分隔多种约束类型，如 `<T extends Length, Type2, Type3>`。

方式 2 - 显式设置特定类型

```ts
function identity<T>(arg: T[]): T[] {
    console.log(arg.length);
    return arg;
}

// or
// function identity<T>(arg: Array<T>): Array<T> {
//     console.log(arg.length);
//     return arg;
// }

// identity(68);   // Error, 类型“number”的参数不能赋给类型“unknown[]”的参数。
identity([1, 2, 3]);
```

### 检查对象上的键是否存在

TS v2.1 引入一个 `keyof` 操作符，该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。

```ts
interface Person {
    name: string,
    age: number,
    location: string,
}

type K1 = keyof Person;
type K2 = keyof Person[];
type K3 = keyof { [x: string]: Person };

function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key];
}
```

使用

```ts

```

## 6. 泛型参数默认类型

<!-- todo -->

## 7. 泛型条件类型

<!-- todo -->

## 8. 泛型工具类

<!-- todo -->

## 9. 使用泛型创建对象

<!-- todo -->

## 10. 参考

[^1]: [深入浅出TypeScript：从基础知识到类型编程](https://juejin.cn/book/6844733813021491207/section/6844733813122154504)
[^2]: [你不知道的 TypeScript 泛型](https://lucifer.ren/blog/2020/06/16/ts-generics/)
[^3]: [一文读懂 TypeScript 泛型及应用（ 7\.8K字）](https://juejin.cn/post/6844904184894980104#comment)