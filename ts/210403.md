# 进击的 TS（1）- 基础类型

## 为什么要用 TypeScript？

好处：

1. 规避大量低级错误，避免时间浪费（省时）
2. 减少多人协作项目的成本，大型项目友好（省心）
3. 良好代码提示，不用反复文件跳转或者翻文档（省力）

坏处：

1. 与其它框架结合会有坑
2. 配置学习成本高
3. 要学习额外的类型系统

## TS 开发环境设置

```sh
# 全局安装（可以使用 `tsc` 命令）
npm install -g typescirpt

# 初始化目录
npm init

# 初始化ts环境（会多一个 `tsconfig.json` 文件，即项目的ts配置文件）
tsc --init
```

在 `package.json` 加上两个 script:

```json
"scripts": {
    "build": "tsc", // 编译
    "build:w": "tsc -w" // 监听文件变化并编译
}
```

参考：

- [官方文档 tsconfig\.json](https://www.tslang.cn/docs/handbook/tsconfig-json.html)
- [理解 Typescript 配置文件](https://segmentfault.com/a/1190000013514680)

## 基础类型

1. 原始类型
   1. `boolean`
   2. `number`
   3. `string`
   4. `void`
   5. `null`
   6. `undefined` 
   7. `symbol`
   8. `bigint`
2. 其它常见类型
   1. `any`
   2. `unknown`
   3. `never`
   4. `Array`
   5. `Tuple`
   6. `Object`

### `boolean` 布尔值 

```ts
const isSpinning: boolean = false;
```

###  `number` 数字

```ts
const size: number = 6;
```

> 注：除了十进制，还可以是十六进制、二进制、八进制字面量。

### `string` 字符串

```ts
const customer: string = 'Tonny';
```

> 注：除了单双引字符串，还可以是模板字符串（被反引号包围）。

### `void` 空值

1. `void` 表示没有任何类型
2. 当一个函数没有返回值时，它的返回类型就是 `void`
3. 声明一个 `void` 类型的变量没什么用，因为它只能被赋予 `undefined` 和 `null`

```ts
function sayHi(): void {
    alert('Hi');
}
```

### `null` & `undefined`

1. 默认情况下，`null` 和 `undefined` 是所有类型的子类型，即可以把它们赋值给以上类型
2. `undefined` 能赋值给 `void`
3. 只有 `--strictNullChecks` 设置为 `false` 时 `null` 才能赋值给 `void`

```ts
let u: undefined = undefined;
let n: null = null;

let v1: void = undefined;    // OK
// let v2: void = null;    // 注意：strictNullChecks=false时才可以这样赋值
```

`tsconfig.json` 开启 `strictNullChecks` 检查：

```json
{
    "compileOnSave": false,
    "compilerOptions": {
        ...
        "strictNullChecks": true,   // Here!
        "skipLibCheck": true,
        ...
    }
}
```

### `symbol`

使用 `Symbol` 时，必须添加 `es6` 的编译辅助库：

```json
{
    ...
    "lib": ["ES6", "DOM"],  // 指定要包含在编译中的库文件
    ...
}
```

该类型通过 `Symbol` 构造函数创建：

```ts
const s1 = Symbol('s1');
const s2 = Symbol('s2');
```

Symbol 的值时唯一不变的：

```ts
Symbol('s1') = Symbol('s1');    // false
```

### `BigInt` 大数整数

使用 `BigInt` 必须添加 `ESNext` 编译辅助库：

```json
"lib": ["es6", "dom", "ESNext"],
```

### `Any` 任何值

1. 可以为还不清楚类型的变量指定该类型 `any`
2. 多人协作协作项目大忌，很可能把 `TypeScript` 变成 `AnyScript`，所以非不得情况不建议使用

```ts
let a: any;
```

### `unknown` 未知值

1. ts 3.0 引入的新类型，`any` 类型对应的安全类型
2. 与 `any` 对比，`unknown` 会更严格：当 `unknown` 类型被确定是某个类型之前，它不能被进行任何操作，如实例化、getter、函数执行等
3. 缩小其类型范围可以执行 `unknown`，如用 instanceof 判断是否日期、数组等具体类型

```ts
let a: any;
a[0] = 1;   // OK

let un: unknown;
// un[0] = 1;  // Error：未确定类型之前不能进行操作
if (un instanceof Array) {  // 缩小范围类型，让unknow可以执行操作
    un[0] = 1;  // OK
}
```

### `never` 永不存在

1. `never` 表示那些永不存在的值的类型
2. 它是任何类型的子类型，即可以赋值给任何类型
3. 没有类型是 `never` 的子类型，即没有任何类型（包括 `any`）可以赋值给 `never`（除了 `never` 本身）
4. 常见的 `never` 类型有：总是会抛出异常或根本就不会有返回值的函数表达式；箭头函数表达式的返回值类型；被永不会为真的类型保护所约束的变量

```ts
// 返回never的函数必须存在无法到达的终点
function error(message: string): never {
    throw new Error(message);
}
```

### `Array` 数组

两种方式可以定义数组：

```ts
// 使用数组泛型，`Array<元素类型>`
let list: Array<number> = [1, 2, 3];

// 使用 `元素类型[]`（这种更常用）
let list: number[] = [1, 2, 3];
```

### `Tuple` 元组

1. 与数组类型很相似，表示一个已知元素数量和类型的数组
2. 元组中元素的类型可以不同

```ts
let t: [string, number]
t = ['hi', 10]; // OK
t = [10, 'hi']; // Error: 元素类型顺序有误
t = ['hi', 10, 10]; // Error: 数组长度
```

### `Object` 对象

1. `Object` 表示非原始类型，也就是除了 `number`, `string`, `boolean`, `symbol`, `bigint`, `null` 或 `undefined` 之外的类型
2. 普通对象、枚举、数组、元组都是 `object` 类型

## 类型断言

<!-- todo -->